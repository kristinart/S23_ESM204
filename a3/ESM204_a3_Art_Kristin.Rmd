---
title: "ESM204_a3_Art_Somhegyi_Berkovitz"
author: "Olivia Somhegyi, Simone Berkovitz, and Kristin Art"
date: "2023-05-16"
output: html_document
---

```{r setup, echo = TRUE, warning = FALSE, message = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, results = TRUE)
library(here)
library(tidyverse)
library(janitor)
library(dplyr)
library(pracma)
library(purrr)
library(wesanderson)
library(stargazer)
library(kableExtra)
library(equatiomatic)
```
### Distributional consequences of the clean energy transition

Use the following set of facts:
• We are concerned about the environmental inequities that may arise between DAC and non- DAC communities in California due to mining of lithium needed to produce batteries in electric vehicles (EVs). We therefore will model the California EV market with two consumer groups: DAC and non-DAC.
• Initially, there is no intervention in the EV market.
• The current EV price (without any intervention) is $50,000 per vehicle.
• The marginal cost of producing an EV is linear and has a price-intercept of 0. For the purposes of this exercise, you can assume that California is self-contained in supply and demand (you don’t need to worry about global EV or mining markets). This is of course unrealistic, but note there have been large efforts by the Biden Administration to create a domestic battery supply chain, making the tradeoffs analyzed here highly policy relevant.

#### Part 1
The data set HW3 data.csv provides price (in $) and quantity (in number of EVs) estimates of demand per year for both DAC and non-DAC groups. Run linear regressions (with an intercept) to estimate the demand curves for DAC and non-DAC consumers. What are 2-3 reasons you can think that may explain the differences in demand you estimate?
dac have lower demand because of lower income, etc. elasticity. dac is more price-sensitive, 
```{r}
#load in data 
ev_raw = read_csv(here("a3/HW3_data.csv")) 

#clean names and pivot longer
ev_df = ev_raw %>% 
  janitor::clean_names() %>% 
  rename('p'= 1, 'dac' = 2,'non_dac' = 3) %>% 
  pivot_longer(cols = dac:non_dac, names_to = "community", values_to = "q")

#run linear regression on raw data and save model's coefficients and intercept for each community
models = ev_df %>% 
  group_by(community) %>% 
  nest() %>% 
  mutate(reg = purrr::map(.x = data, ~lm(p~q, data = .x)), #create regression column
         coeff = map_dbl(reg, ~ coefficients(.x)["q"]), #create column w/ lm coefficients
         int = map_dbl(reg, ~ coefficients(.x)["(Intercept)"])) %>%  #create column w/ lm intercept
  select(-c(data,reg)) #only select columns of interest

#define model outputs as objects for ease of use
#slopes
dac_slope = models$coeff[models$community == 'dac']
non_slope = models$coeff[models$community == 'non_dac']
#intercepts
dac_int = models$int[models$community == 'dac']
non_int = models$int[models$community == 'non_dac']
```

```{r}
#plot demand estimates and lm curves
plot_1 = 
  ggplot(ev_df, aes(x = q, y = p, color = community)) +
  geom_point(size = 2) + 
  #geom_abline(slope = dac_slope, intercept = dac_int) +
  #geom_abline(slope = non_slope, intercept = non_int) + #don't know how to clip the ablines where they cross the axes, so plotted with segment instead
  geom_segment(data = ev_df, x = 0, y = non_int, xend = 57868.38, yend = 0)+
  geom_segment(data = ev_df, x = 0, y = dac_int, xend = 17674.65, yend = 0)+
  geom_segment(data = ev_df, aes(x = 0, y = non_int, xend = 15078.93, yend = dac_int, colour = "aggregate"))+
  geom_segment(data = ev_df, aes(x = 15078.93, y = dac_int, xend = 75543.04, yend = 0, colour = "aggregate"))+
  scale_color_manual(values= wes_palette("GrandBudapest1", n = 3)) +
  labs(x = "Quantity (EVs)", y =  "Price ($/EV)", color = "Community", title = "Demand for Electric Vehicles (EVs)") +
  ylim(0,175000)+
  xlim(0,80000)+
  theme_minimal() +
  theme()

plot_1

```

#### Part 2
```{r}
li_mc = 300 #marginal cost of 1 kg of lithium mined for batteries
n_li = 63 #kg of lithium used in one EV

ev_MEC = li_mc*n_li 

```

If the marginal externality cost of 1 kg of lithium is $300 and 63 kg of lithium are used during the production of one EV, then the marginal externality cost per EV produced is 
$`r ev_MEC`. 

#### Part 3 Traditional Market 
What is the aggregate annual demand curve for EVs? What is the supply curve for EVs? What is the “benefit” to consumers under the status quo? What is the “benefit” to producers under the status quo? What is the environmental cost under the status quo?
```{r}
#define demand functions
#define generic demand function to calculate Q 
compute_d_Q = function(P, int, slope){
  Q = (P - int)/ slope
  return(Q)
}

#define aggregate demand function to solve for Q
agg_d_Q = function(P){
  #if the input price is equal to or greater than the intercept of the DAC curve, then calculate Q based on the non-DAC curve alone 
  if(P >= dac_int) {
    Q_agg  = compute_d_Q(P = P, int = non_int, non_slope)}
  
  #if the input price is less than the intercept of the DAC curve, then calculate Q by adding the demand curves for both DAC and non-DAC
  if(P < dac_int) {
    Q_agg = compute_d_Q(P = P, int = non_int, non_slope) + compute_d_Q(P = P, int = dac_int, dac_slope)
  }
  
  #return Q value from above situation based on the input P
  return(Q_agg)
}

#define generic demand function to calculate P
compute_d_P = function(Q, int, slope){
  P = int + slope*Q
  return(P)
}

#define aggregate demand function to solve for P
agg_d_P = function(Q){
  P = ((75543.03807 - Q)/0.517429209)
  return(P)
}

#find eq Q based on known eq P
P_eq = 50000
Q_eq = agg_d_Q(P_eq)

#calculate MPC slope based on rise/ run between (0,0) and (Q_eq, P_eq)
MPC_slope = P_eq/Q_eq

#define generic function to calculate consumer surplus, note can only use on individual demand curves, not aggregate (due to kinked curve)
compute_CS = function(P, int, slope){
  CS = 0.5*(int - P)*(compute_d_Q(P, int, slope))
  return(CS)
}

#find consumer surplus by adding CS for each community
CS = (compute_CS(P = P_eq, int = dac_int, slope = dac_slope)) + (compute_CS(P = P_eq, int = non_int, slope = non_slope))

#define marginal private cost curve to solve for P
MPC_P = function(Q){
  P = MPC_slope*Q
  return(P)
}

#define marginal social cost curve to solve for P
MSC_P = function(Q){
  P = ev_MEC + MPC_slope*Q
  return(P)
}

#find producer surplus by calculating total area under supply curve
PS = integral(f = MPC_P, xmin = 0, xmax = Q_eq)


#calculate socially optimal P by adding so tax to previous P eq
P_so = P_eq + ev_MEC

#then solve for Q by plugging into agg demand curve
Q_so = agg_d_Q(P_so)

#find total environmental damage
TC_env = ev_MEC*Q_so
```

a) Aggregate annual demand curve for EVs

For DAC communities, the demand curve for EVs is given by P = `r dac_int` + `r dac_slope`*Q. 
Rearranged, the demand curve is Q = (P - `r dac_int`)/ `r dac_slope`.

For non-DAC communities, the demand curve for EVs is given by P = `r non_int` + `r non_slope`*Q. 
Rearranged, the demand curve is Q = (P - `r non_int`)/ `r non_slope`.

The aggregate demand curve for EVs is therefore Q = ((P - `r dac_int`)/ `r dac_slope`) + ((P - `r non_int`)/ `r non_slope`), which is equal to $$Q = 75543.03 - 0.5174292*P.$$
Rearranged, the aggregate demand curve is $$P = 145996.8 - 1.932632*Q$$

b) Supply curve for EVs is given by P = `r MPC_slope`*Q, or $$P = 1.006612Q$$

c) The “benefit” to consumers under the status quo, also known as the consumer surplus, is `r CS`.

d) The “benefit” to producers under the status quo, also known as the producer surplus, is `r PS`.

e) The total environmental cost under the status quo is `r TC_env`

#### Part 4:
How is the current consumer benefit divided between DAC and non-DAC consumers?
```{r}
#find consumer surplus for each community
dac_CS = compute_CS(P = P_eq, int = dac_int, dac_slope)
non_CS = compute_CS(P = P_eq, int = non_int, non_slope)

#calculate the percent of the total CS that each community receives
dac_perc_CS = round((dac_CS/(dac_CS + non_CS))*100)
non_perc_CS = round((non_CS/(dac_CS + non_CS))*100)

#make a table for results
names = c("DAC", "Non-DAC", "Total")
cs = c(round(dac_CS), round(non_CS), round(CS))
perc = c("14%", "86%", "100%")
table_1 = cbind(names, cs, perc)
```

```{r}
kable(table_1, format = "markdown", caption = "Table 1: Breakdown of consumer benefits in the traditional market", col.names = c("Community", "Consumer Benefit ($)", "% Total"))

```

Non-DAC receive `r non_perc_CS`% of the current consumer benefits, while DAC only receive `r dac_perc_CS`% of the current consumer benefits. The total consumer surplus is $`r CS`.

#### Part 5
Derive the optimal EV tax (in $ per vehicle) to internalize the lithium mining externality. Noting that recent research has shown that DACs are far more likely to contain mining activity, assume that the mining externality is borne entirely by the DAC group. What would be the effects of this tax on:
(a) The amount of EVs produced and consumed 
(b) The price of EVs
(c) Overall welfare of non-DAC consumers 
(d) Overall welfare of DAC consumers
(e) EV producers
(f) Total environmental damage
(g) Total tax revenue generated

```{r}
#define socially optimal tax
tax_so = ev_MEC

#find the quantity difference between market equilibrium and socially optimal equilibrium 
Q_diff = Q_eq - Q_so

#find the quantity difference between market equilibrium and socially optimal equilibrium 
P_diff = P_so - P_eq

#calculate the total welfare of nonDAC as the CS
TW_non_so = compute_CS(P_so, non_int, non_slope)

#calculate the total environmental damage by multiplying the mec of one EV by the quantity consumed
TC_env = Q_so*ev_MEC

#calculate the total tax revenue generated, which is equivalent to total env damage
TB_tax = Q_so*tax_so

#calculate the total welfare of DAC as the CS - total environmental damage
TW_dac_so = compute_CS(P_so, dac_int, dac_slope) - TC_env

#calculate the producer surplus as the area under the supply curve - total environmental damage
PS_so = integral(f = MSC_P, xmin = 0, xmax = Q_so) - TC_env
PS_diff = PS - PS_so


#show results in a table
table_2 = bind_cols("Variable" = c("Price", "Quantity", "Non-DAC Welfare", "DAC Welfare", "Producer Surplus", "Total Environmental Damage", "Total Tax Revenue"),
                  "Value" = c(P_so, Q_so, TW_non_so, TW_dac_so, PS_so, TC_env, TB_tax))

kable(table_2, format = "markdown", caption = "Table 2: Market equilibrium and surpluses under socially optimal tax")
```

The socially optimal tax is equivalent to the marginal externality cost (MEC) of lithium mining and is `r tax_so`.

a) When the EV tax is applied, the quantity of EVs produced and consumes decreases by `r Q_diff` to `r Q_so`. 

b) When the EV tax is applied, the price for EVs increases by `r P_diff` to `r P_so`.

c) With the tax, the total welfare of non-DAC is `r TW_non_so`.

d) With the tax, the total welfare of DAC is `r TW_dac_so`.

e) With the tax, the total welfare of producers decreases by `r PS_diff` to `r PS_so`.

f) The total environmental damage is `r TC_env`. 

g) The total tax revenue generated is `r TB_tax`, which is equivalent to the total environmental damage.

#### Part 6
Now, assume that all revenue from the EV tax will be redistributed to the consumers in proportion to their pre-tax consumption. For example, if 80% of the EVs were consumed by non-DAC consumers, then they get 80% of the tax revenue. Additionally, consider that emerging scientific evidence suggests the true environmental damages from lithium mining may be much higher than $300. 
For a range of values of external costs per kg of lithium ($350, $400, $450, and $500 per kg), calculate the effects of an EV tax on:1
(a) Overall welfare of non-DAC consumers 
(b) Overall welfare of DAC consumers
(c) EV producers

```{r}
#calculate n of EVs consumed by each community  in traditional market
Q_eq_dac = dac_int/(MPC_slope + abs(dac_slope))
Q_eq_non = non_int/(MPC_slope + abs(non_slope))

#calculate proportion of EVs consumed by each community  
Q_shares_dac = (Q_eq_dac/ (Q_eq_dac + Q_eq_non))
Q_shares_non = (Q_eq_non/ (Q_eq_dac + Q_eq_non))

#calculate percentage of EVs consumed by each community  
Q_perc_dac = round(100*Q_shares_dac)
Q_perc_non = round(100*Q_shares_non)

```
DAC consumed `r Q_perc_dac`% of the EVs while non-DAC consumed `r Q_perc_non`% of the EVs.

```{r, results = FALSE}
#method 1
#create df of potential li mecs
li_mec = c(300, 350, 400, 450, 500)
li_mec = as.data.frame(li_mec)

#calculate the things
welfare_results = li_mec %>%
  mutate(ev_mec = as.numeric(n_li*li_mec),
         p_so = as.numeric(P_eq + ev_mec),
         q_so = as.numeric(purrr::map(.x = p_so, .f = agg_d_Q)),
         non_CS = as.numeric(purrr::map(.x = p_so, non_int, non_slope, .f = compute_CS)),
         dac_CS = as.numeric(purrr::map(.x = p_so, dac_int, dac_slope, .f = compute_CS)),
         tax_rev = as.numeric(ev_mec*Q_so),  #this is also the MEC
         non_tax_rev = as.numeric(Q_shares_non*tax_rev),
         dac_tax_rev = as.numeric(Q_shares_dac*tax_rev),
         non_TW = as.numeric(non_CS + non_tax_rev),
         dac_TW = as.numeric(dac_CS + dac_tax_rev - q_so*tax_rev),
         p_TW = as.numeric(0.5*(q_so)*(p_so - ev_mec))) %>% 
  select(li_mec, non_TW, dac_TW, p_TW)

#report in a table
kable(welfare_results, format = "markdown", caption = "Table 3: Total welfare for three groups based on the given scenario", col.names = c("Lithium MEC", "Non-DAC Total Welfare", "DAC Total Welfare", "Producers Total Welfare"))

```

```{r}
#method 2
#define function to calculate welfare of three groups
summarize_welfare = function(li_mec){
  #compute mec of evs by multiplying cost of 1 kg lithium by number of lithium used in one ev
  ev_mec = li_mec*n_li

  #compute socially optimal price as the traditional market price + ev mec
  p_so = ev_mec + P_eq
  
  #define agg demand curve function without the piecewise situation, since it won't knit otherwise -_-
  agg_d_Q = function(P){
    Q_agg = compute_d_Q(P = P, int = non_int, non_slope) + compute_d_Q(P = P, int = dac_int, dac_slope)
    return(Q_agg)
  }
  
  #compute socially optimal q
  q_so = agg_d_Q(p_so)

  #compute tax revenue, aka total env cost
  tax_rev = ev_mec*q_so
  env_cost = tax_rev*q_so

  #compute CS for each group
  non_CS = compute_CS(p_so, non_int, non_slope)
  dac_CS = compute_CS(p_so, dac_int, dac_slope)

  #compute share of tax rev each group will receive
  non_tax_rev = Q_shares_non*tax_rev
  dac_tax_rev = Q_shares_dac*tax_rev

  #compute total welfare of each group
  non_TW = non_CS + non_tax_rev
  dac_TW = dac_CS + dac_tax_rev - env_cost

  #find PS
  p_TW = 0.5*(q_so)*(p_so - ev_mec)

  #format results
  results = tibble(li_mec = li_mec, non_TW = non_TW, dac_TW = dac_TW, p_TW = p_TW)

  return(results)
}

#test function with one input
test_results = summarize_welfare(300)

#create df of potential li mecs
li_mec = c(300, 350, 400, 450, 500)
li_mec = as.data.frame(li_mec)

#apply function to potential li mecs
welfare_results = map_dfr(li_mec, summarize_welfare)

#report in a table
kable(welfare_results, format = "markdown", caption = "Table 3: Total welfare for three groups based on the given scenario", col.names = c("Lithium MEC", "Non-DAC Total Welfare", "DAC Total Welfare", "Producers Total Welfare"))
```

#### Part 7
